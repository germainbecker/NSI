
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Introduction">Introduction<a class="anchor-link" href="#Introduction">&#182;</a></h1><p>On dispose de la grille $2 \times 3$ ci-dessous.</p>
<p><img class="centre image-responsive" alt="une grille" src="data/prog_dyn_intro.png"></p>
<p><strong>Question</strong> : Combien de chemins mènent du coin supérieur gauche au coin inférieur droit, en se déplaçant uniquement le long des traits horizontaux vers la droite et le long des traits verticaux vers le bas ? Et pour une grille $10 \times 10$ ?</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Principe-de-la-programmation-dynamique">Principe de la programmation dynamique<a class="anchor-link" href="#Principe-de-la-programmation-dynamique">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="important">
    <p>La <strong>programmation dynamique</strong> est une technique dûe à <a href="https://fr.wikipedia.org/wiki/Richard_Bellman" target="_blank">Richard Bellman</a> dans les années 1950. À l'origine, cette méthode algorithmique était utilisée pour résoudre des problèmes d'optimisation. L'idée générale est de déterminer un résultat sur la base de calculs précédents.</p>
    <p>Plus précisément, la programmation dynamique consiste à résoudre un problème en le décomposant en sous-problèmes, puis à résoudre les sous-problèmes, des plus petits au plus grands <strong>en stockant les résultats intermédiaires</strong>.
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p>Le terme <em>programmation</em> désigne la <em>planification</em>, et n'a pas de rapport avec les langages de programmation.</p>
</blockquote>
<p>Nous allons illustrer le principe de la programmation dynamique sur le calcul du $n$-ième terme de la suite de Fibonacci.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="La-suite-de-Fibonacci">La suite de Fibonacci<a class="anchor-link" href="#La-suite-de-Fibonacci">&#182;</a></h1><h2 id="Rappels-sur-la-suite-de-Fibonacci">Rappels sur la suite de Fibonacci<a class="anchor-link" href="#Rappels-sur-la-suite-de-Fibonacci">&#182;</a></h2><p>On a déjà abordé cette suite lorsque nous avons parlé de la programmation récursive (<a href="https://nbviewer.jupyter.org/github/germainbecker/NSI/blob/master/Terminale/Theme4_Langage_programmation/Activites_Recursivite.ipynb#Activit%C3%A9-4-:-Suite-de-Fibonacci">Thème 4, Chapitre 1</a>). Mais voilà quelques rappels :</p>
<p>La suite de Fibonnacci est une suite de nombres dont chacun est la somme des deux précédents. Le premier et le second nombres sont égaux à 0 et 1 respectivement. On obtient la suite de nombres : 0 - 1 - 1 - 2 - 3 - 5 - 8 - 13 - 21 - ...</p>
<p>Mathématiquement, cette suite notée $(F_n)$ est donc définie par :</p>
$$\left\{
\begin{array}{l}
  F_0 = 0 \\
  F_1 = 1 \\
  F_{n} = F_{n-1} + F_{n-2} \text{ pour tout entier } n \geqslant 2
\end{array}
\right.$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Version-r&#233;cursive-na&#239;ve-(et-inefficace)">Version r&#233;cursive na&#239;ve (et inefficace)<a class="anchor-link" href="#Version-r&#233;cursive-na&#239;ve-(et-inefficace)">&#182;</a></h2><p>Vous avez déjà programmé une version récursive qui renvoie le terme de rang $n$ de cette suite.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version récursive naïve&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Par exemple, voici l'arbre des appels récursifs si on lance <code>fibo(5)</code>.</p>

<pre><code>                           fib(5)   
                     /                \
               fib(4)                fib(3)   
             /        \              /       \ 
         fib(3)      fib(2)         fib(2)   fib(1)
        /    \       /    \        /      \
  fib(2)   fib(1)  fib(1) fib(0) fib(1) fib(0)
  /     \
fib(1) fib(0)</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On se rend compte qu'il y a beaucoup d'appels redondants : <code>fib(1)</code> a été lancé 5 fois, <code>fib(2)</code> a été lancé 3 fois, etc.</p>
<p>Ces redondances entraînent un nombre d'appels récursifs qui explose rapidement dès que $n$ est élevé. Par conséquent, les temps de calcul deviennent vite très élevés. Pire, dès que $n$ est trop grand, l'algorithme ne donnera jamais la réponse.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(5)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[2]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>5</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(30)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 367 ms
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[3]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>832040</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(37)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 12.9 s
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>24157817</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p>Il est possible de faire mieux, en évitant de refaire les calculs déjà effectués. Pour cela, il faut <strong>stocker les résultats intermédiaires</strong> !</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Version-r&#233;cursive-avec-m&#233;mo&#239;sation">Version r&#233;cursive avec <em>m&#233;mo&#239;sation</em><a class="anchor-link" href="#Version-r&#233;cursive-avec-m&#233;mo&#239;sation">&#182;</a></h2><p>Une première approche est d'adapter l'algorithme récursif en stockant les résultats calculés dans un tableau ou un dictionnaire. Lors d'un appel, on commence par vérifier si on ne connaît pas déjà la réponse, auquel cas on la renvoie directement, ce qui évite d'effectuer des calculs redondants.</p>
<p>Cela donne la fonction <code>fibo_memo</code> suivante qui prend en paramètres un entier <code>n</code> et un dictionnaire <code>memo</code> que l'on met à jour en stockant les résultats intermédiaires au fur et à mesure.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fibo_memo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>      <span class="c1"># si calcul déjà effectué</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># on renvoie directement sa valeur</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibo_memo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo_memo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Explications</strong> :</p>
<ul>
<li>Lignes 2 et 3 : si la valeur <code>n</code> est déjà dans le dictionnaire, c'est qu'on a déjà calculé $F_n$ et il suffit alors de renvoyer sa valeur <code>mem[n]</code> (la valeur associée à <code>n</code>).</li>
<li>Lignes 4 à 9 : quasiment identiques à la version récursive naïve à ceci près que l'on mémorise la valeur dans le dictionnaire <code>memo</code> avant de la renvoyer</li>
<li>De cette façon, dès qu'une valeur $F_n$ a été calculée, elle est ajoutée dans le dictionnaire comme la valeur associée à $n$, ce qui permet de la réutiliser directement dès qu'on en a besoin.</li>
</ul>
<p>Il n'y a plus qu'à lancer le premier appel avec un dictionnaire vide, c'est ce que fait la fonction <code>fibo</code> suivante.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version récursive avec mémoïsation&quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">fibo_memo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Avec ce procédé de mémoïsation, l'arbre des appels est considérablement réduit puisqu'il n'y a plus aucun appel redondant. Par exemple, l'arbre des appels récursifs en lançant <code>fibo(5)</code> se réduit à :</p>

<pre><code>                           fib(5)   
                     /                \
               fib(4)                fib(3)   
             /        \ 
         fib(3)      fib(2)         
        /    \       
  fib(2)   fib(1)  
  /     \
fib(1) fib(0)</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On constate alors qu'avec cette version, les valeurs $F_n$ sont calculées quasiment instantanément et que l'on peut obtenir les valeurs $F_n$ pour des grandes valeurs de $n$.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(5)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>5</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(30)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>832040</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(37)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[9]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>24157817</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(850)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 2.04 ms
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[10]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>1949885951587339044875793733356219760673772926586260591210358470405525665390243100575540781157408285819450131557173898143210104351541330710230926558457389046268596497514105167175</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="M&#233;thode-descendante">M&#233;thode <em>descendante</em><a class="anchor-link" href="#M&#233;thode-descendante">&#182;</a></h3><p>La version récursive avec mémoïsation correspond à une approche <em>descendante</em>, aussi appelée <em>haut-bas</em> (ou <em>top-down</em> en anglais). En effet, pour connaître $F_n$ on lance l'appel <code>fibo(n)</code> qui déclenche la descente d'appels récursifs jusqu'aux cas de base pour lesquels on mémorise les résultats. Dans un second temps, on remonte les appels tout en mémorisant leurs résultats pour ne pas résoudre plusieurs fois le même problème.</p>
<p>Finalement, avec cette méthode, c'est lors de la remontée des appels que leurs résultats sont mémorisés puis réutilisés sur les problèmes plus grands. On peut alors se demander si on ne peut pas procéder directement du plus petit sous-problème au plus grand (celui que l'on veut résoudre). La réponse est oui ! Et on explique cela de suite.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Version-it&#233;rative-ascendante">Version it&#233;rative <em>ascendante</em><a class="anchor-link" href="#Version-it&#233;rative-ascendante">&#182;</a></h2><blockquote><p>On parle aussi de méthode <em>bas-haut</em>, ou <em>bottom-up</em> en anglais.</p>
</blockquote>
<p>Une autre manière de résoudre le problème est d'utiliser une approche <em>ascendante</em>.</p>
<p>Il s'agit d'une méthode <strong>itérative</strong> dans laquelle on commence par calculer des solutions pour les sous-problèmes les plus petis puis, de proche en proche, on arrivera à la taille voulue. Comme précédemment, on utilise le principe de la mémoïsation pour stocker les résultats partiels.</p>
<p>Le calcul du terme $F_n$ de la suite de la Fibonacci n'est pas un problème d'optimisation, ainsi le calcul d'une solution d'un problème à partir des solutions connues des sous-problèmes est simple puisqu'il n'y a aucun choix à faire.</p>
<p>De manière générale, on utilise un tableau pour stocker les résultats au fur et à mesure. Voici les étapes habituelles :</p>
<ol>
<li><strong>Création et initialisation du tableau</strong> : <ul>
<li>On a besoin d'un tableau <code>F</code> de taille $n+1$ qui va contenir les valeurs $F_0$, $F_1$, ..., $F_n$ dans cet ordre</li>
<li>Pour cela on crée le tableau <code>F</code> avec $n+1$ zéros initialement</li>
<li>On peut stocker les valeurs déjà connues ($F_0$ et $F_1$ dans notre cas)</li>
</ul>
</li>
<li><strong>Utilisation de la formule de récurrence pour remplir le reste du tableau</strong> :<ul>
<li>La formule de récurrence donne la solution d'un sous-problème à partir de celles de sous-problèmes plus petits et donc déjà traités ! Ici on a pour $2\leq i \leq n$ : $F_i =  F_{i-1}$ et $F_{i-2}$</li>
<li>On peut donc remplir le tableau <code>F</code> en parcourant les indices <strong>par ordre croissant</strong> : on va mettre dans <code>F[i]</code> la valeur <code>F[i-1] + F[i-2]</code> que l'on connaît puisque ces deux valeurs ont été calculés précédemment.</li>
</ul>
</li>
<li><strong>Le résultat est dans la dernier case du tableau</strong> : on la renvoie !</li>
</ol>
<p>Cela donne la fonction suivante.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version itérative ascendante&quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># pas indispensable car déjà initialisé à 0</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Les performances sont semblables à la version récursive avec mémoïsation</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">time</span> fibo(850)
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>1949885951587339044875793733356219760673772926586260591210358470405525665390243100575540781157408285819450131557173898143210104351541330710230926558457389046268596497514105167175</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Autres-probl&#232;mes">Autres probl&#232;mes<a class="anchor-link" href="#Autres-probl&#232;mes">&#182;</a></h1><p>Il existe de nombreux problèmes pouvant être résolus avec le paradigme de la programmation dynamique, dont beaucoup de problèmes d'optimisation :</p>
<ul>
<li>Problème du rendu de monnaie (traité en exercice)</li>
<li>Problème du sac-à-dos (version gloutonne abordée en classe de Première)</li>
<li>Alignement de séquences (traité en exercice)</li>
<li>Problème du plus court chemin (<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Bellman-Ford">Algorithme de Bellman-Ford</a> utilisé par le protocole RIP)</li>
<li>Problèmes d'ordonnancement d'intervalles pondérés (<a href="http://www-desir.lip6.fr/~spanjaard/pmwiki/uploads/ProgrammationDynamique.pdf">voir ici</a>)</li>
<li>Toutes sortes de problème d'affectation des ressources</li>
<li>etc.</li>
</ul>
<blockquote><p>Passez aux exercices !</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Le programme officiel cite les exemples du rendu de monnaie et de l'alignement de séquences comme des exemples pouvant être présentés. Il sont détaillés en exercices mais voici tout de même un résumé condensé qui pourra servir de révisions.</p>
<h2 id="Rendu-de-monnaie">Rendu de monnaie<a class="anchor-link" href="#Rendu-de-monnaie">&#182;</a></h2><p>On a vu en Première que l'on peut résoudre ce problème avec un algorithme glouton mais que ce dernier ne fournit pas nécessairement une solution optimale (et parfois fausse selon le système monétaire utilisé).</p>
<p>Une autre approche est d'utiliser la force brute en testant toutes les combinaisons possibles. On peut le faire de manière récursive mais le nombre de combinaisons à tester devient vite trop important pour que cette solution soit satisfaisante.</p>
<h3 id="Relation-de-r&#233;currence">Relation de r&#233;currence<a class="anchor-link" href="#Relation-de-r&#233;currence">&#182;</a></h3><p>On peut chercher à exprimer le problème (rendre une somme $n$) à partir de sous-problèmes plus petits (rendre une somme plus petite que $n$). On aboutit à la relation de récurrence suivante sur le nombre de pièces optimal pour rendre une somme $n$ :</p>
$$\text{nb_pieces}(n) = \left\{
\begin{array}{l}
  0 \hspace{5cm} \textrm{ si } n = 0\\
  1 + \displaystyle\min_{p\leq n}(\text{nb_pieces}(n-p)) \hspace{0.5cm} \textrm{ sinon }
\end{array}
\right.$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En effet, l'idée est la suivante : pour rendre la somme $n$ de façon optimale il faut rendre une pièce $p$ est la somme $n-p$ de façon optimale. Pour cela, il faut tester toutes les pièces $p$ possibles et prendre celle qui minimise le nombre de pièces pour rendre pour la somme $n-p$ (d'où la recherche du minimum)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Version-r&#233;cursive-avec-m&#233;mo&#239;sation">Version r&#233;cursive avec m&#233;mo&#239;sation<a class="anchor-link" href="#Version-r&#233;cursive-avec-m&#233;mo&#239;sation">&#182;</a></h3><p>L'algorithme récursif classique a une efficacité catastrophique car le nombre d'appels explose car il y a beaucoup de redondances. On peut améliorer cette version récursive en utilisant la programmation dynamique : pour cela on stocke les résultats connus dans un tableau <code>memo</code> et on renvoie directement les résultats connus pour éviter les appels récursifs redondants.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">rendu_monnaie</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pieces</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version récursive avec mémoïsation&quot;&quot;&quot;</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># intialisation du tableau avec des None </span>
    <span class="k">return</span> <span class="n">rendu_monnaie_memo</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rendu_monnaie_memo</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">memo</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># si on a déjà calculé le nombre optimal de pièces pour rendre la somme s</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>      <span class="c1"># on le renvoie directement</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nb_pieces</span> <span class="o">=</span> <span class="n">s</span>     <span class="c1"># nb_pieces = 1 + 1 + ... + 1 dans le pire des cas</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">:</span>   <span class="c1"># inutile de tester une pièce dont la valeur dépasse la somme s à rendre</span>
                <span class="n">nb_pieces_bis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rendu_monnaie_memo</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
                <span class="n">nb_pieces</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_pieces</span><span class="p">,</span> <span class="n">nb_pieces_bis</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_pieces</span>
        <span class="k">return</span> <span class="n">nb_pieces</span>

<span class="c1"># ESSAI</span>
<span class="n">rendu_monnaie</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[13]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>50</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Version-it&#233;rative-ascendante">Version it&#233;rative ascendante<a class="anchor-link" href="#Version-it&#233;rative-ascendante">&#182;</a></h3><p>On procède classiquement :</p>
<ol>
<li><strong>Création et initialisation du tableau</strong> : <ul>
<li>On a besoin d'un tableau <code>nb</code> de taille $s+1$ qui va permettre de stocker les valeurs $\text{nb_pieces}(0)$, $\text{nb_pieces}(1)$, ..., $\text{nb_pieces}(s)$ dans cet ordre.</li>
<li>Pour cela on crée le tableau <code>nb</code> avec $n+1$ zéros initialement</li>
<li>La valeur connue <code>nb[0]</code> est alors déjà correctement initialisée</li>
</ul>
</li>
<li><strong>Utilisation de la formule de récurrence pour remplir le reste du tableau</strong> :<ul>
<li>Formule de récurrence :  $$\text{nb}[n] = 1 + \min_{p \leq n} \left(\text{nb}[n-p] \right)$$</li>
<li>On peut donc remplir le tableau <code>nb</code> en parcourant les indices <strong>par ordre croissant</strong> (on fait varier <code>n</code> de <code>1</code> à <code>s</code>) en utilisant la formule de récurrence</li>
</ul>
</li>
<li><strong>Le résultat est dans la dernier case du tableau</strong> : on la renvoie !</li>
</ol>
<p>Cela donne la fonction suivante.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">rendu_monnaie</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pieces</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version itérative ascendante&quot;&quot;&quot;</span>
    
    <span class="c1"># ÉTAPE 1 : création et initialisation du tableau</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># nb[0] est ainsi bien initialisé</span>
    
    <span class="c1"># ÉTAPE 2 : remplissage du reste du tableau par indice croissant</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>    
        <span class="n">nb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>       <span class="c1"># nb[n] = 1 + 1 + ... + dans le pire des cas</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">nb_bis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">nb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">p</span><span class="p">]</span>
                <span class="n">nb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">nb_bis</span><span class="p">)</span>
    
    <span class="c1"># ÉTAPE 3 : le résultat est dans la dernière case</span>
    <span class="k">return</span> <span class="n">nb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="c1"># ESSAI</span>
<span class="n">rendu_monnaie</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[14]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>50</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Alignement-de-s&#233;quences">Alignement de s&#233;quences<a class="anchor-link" href="#Alignement-de-s&#233;quences">&#182;</a></h2><p><strong>Décontextualisation</strong> : On peut représenter deux séquences comme deux chaînes de caractères $T_1$ et $T_2$ et l'objectif est d'étudier leur degré de similarité (ou dissimilarité). Pour cela on peut chercher à <em>minimiser</em> la <em>distance</em> $d(T_1, T_2)$ entre les deux chaînes.</p>
<p>Pour passer d'une chaîne à l'autre on dispose de 3 opérations chacune ayant un coût égal à 1 :</p>
<ul>
<li>insertion (d'un caractère $c$ dans $T_1$)</li>
<li>suppression (d'un caractère $c$ dans $T_1$)</li>
<li>substitution (d'un caractère $c$ par un autre caractère $c'$ dans $T_1$)</li>
</ul>
<p>On appelle <strong>distance d'édition</strong>, notée $\text{dE}$, le nombre minimal de caractères qu'il faut insérer, supprimer, ou substituer pour passer d'une chaîne à l'autre, c'est-à-dire celle qui minimise le coût des alignements possibles. La distance d'édition permet donc d'obtenir un aligment optimal.</p>
<p><strong>Exemple</strong> : Un alignement optimal des chaînes SUCCES et ECHECS est</p>

<pre><code>S U C C E - S
- E C H E C S</code></pre>
<p>dont le coût est égal à 4, donc $\text{dE(SUCCES, ECHECS) = 4}$</p>
<h3 id="Relation-de-r&#233;currence">Relation de r&#233;currence<a class="anchor-link" href="#Relation-de-r&#233;currence">&#182;</a></h3><p>On peut dégager une relation de récurrence car le calcul de la distance d'édition entre deux chaînes peut se faire à partir de celles de chaînes plus petites.</p>
<p>On a la relation suivante :</p>
$$\text{dE}(T_1[1..i], T_2[1..j]) = \min \left\{
\begin{array}{l}
  \text{dE}(T_1[1..i-1], T_2[1..j]) + 1\\
  \text{dE}(T_1[1..i], T_2[1..j-1]) + 1\\
  \text{dE}(T_1[1..i-1], T_2[1..j-1]) + \text{sub}(T_1[i], T_2[j])
\end{array}
\right.$$<p>où $\text{sub}(a, b) = \left\{
\begin{array}{l}
  0 \text{ si } a = b \text{ (correspondance)}\\
  1 \text{ si } a \neq b \text{ (substitution)}
\end{array}
\right.
$</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En effet, pour aligner de manière optimale $T_1[1..i]$ et $T_2[1..j]$, il y a trois cas de figure :</p>
<ul>
<li>$T_1[i]$ s'aligne sur &laquo; - &raquo;. Cela demande à avoir aligné $T_1[1..i-1]$ et $T_2[1..j]$ de manière optimale et supprimé $T_1[i]$. </li>
<li>&laquo; - &raquo; s'aligne sur $T_2[j]$. Cela demande à avoir aligné $T_1[1..i]$ et $T_2[1..j-1]$ de manière optimale et inséré $T_2[j]$.</li>
<li>$T_1[i]$ s'aligne sur $T_2[j]$ :<ul>
<li>si $T_1[i] \neq T_2[j]$, cela demande à avoir aligné $T_1[1..i-1]$ et $T_2[1..j-1]$ de manière optimale et substitué $T_1[i]$ par $T_2[j]$. </li>
<li>si $T_1[i] = T_2[j]$. Cela demande d'avoir aligné $T_1[1..i-1]$ et $T_2[1..j-1]$ de manière optimale et c'est tout (sans surcoût) </li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p>La version récursive naïve permettant de calculer la distance d'édition a un coût en temps catastrophique car les appels sont redondants. On peut améliorer cela à l'aide de la technique de mémoïsation comme pour les autres exemples mais on ne présente dans la suite que la version itérative ascendante.</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Version-it&#233;rative-ascendante">Version it&#233;rative ascendante<a class="anchor-link" href="#Version-it&#233;rative-ascendante">&#182;</a></h3><p>On note $n_1$ et $n_2$ les longueurs respectives de $T_1$ et $T_2$.</p>
<p>On procède classiquement :</p>
<ol>
<li><p><strong>Création et initialisation du tableau</strong> :</p>
<ul>
<li>On a besoin d'un tableau <code>D</code> à deux dimensions de taille $(n1 + 1)\times(n2 + 1)$ qui va permettre de stocker en position $(i, j)$ la distance d'édition entre les $i$ premiers caractères de $T_1$ et les $j$ premiers caractères $T_2$ (<code>D[i][j]</code> $= \text{dE}(T_1[1..i], T_2[1..j])$).</li>
<li>Pour cela on crée le tableau <code>D</code> avec uniquement des zéros</li>
<li>On peut remplir la première ligne et la première colonne facilement</li>
<li><p>À ce stade on obtient le tableau suivant dans lequel on n'a pas représenté les 0 dans les cases vides puisqu'ils seront écrasés au fur et à mesure du remplissage</p>
<p><img src="data/tableau_align_seq2.png" alt="tableau"></p>
</li>
</ul>
</li>
<li><p><strong>Utilisation de la formule de récurrence pour remplir le reste du tableau</strong> :</p>
<ul>
<li>Formule de récurrence :  $$\text{nb[i][j]} = \min \left\{
\begin{array}{l}
\text{nb[i-1][j]} + 1 \text{ (suppression)}\\
\text{nb[i][j-1]} + 1 \text{ (insertion)}\\
\text{nb[i-1][j-1]} + \left\{
\begin{array}{l}
0 \text{ si } T_1[i] = T_2[j] \text{ (correspondance)}\\
1 \text{ si } T_1[i] \neq T_2[j]  \text{ (substitution)}
\end{array}
\right.
\end{array}
\right.$$</li>
<li>On peut donc remplir le tableau <code>nb</code> avec deux boucles imbriquées qui parcourent les indices <strong>par ordre croissant</strong> (on fait varier $i$ de $1$ à $n_1$ et $j$ de $1$ à $n_2$ ) en utilisant la formule de récurrence.</li>
</ul>
</li>
<li><strong>Le résultat est dans la dernier case du tableau</strong> : on la renvoie !</li>
</ol>
<p>Cela donne la fonction suivante.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">dE</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Version itérative ascendante&quot;&quot;&quot;</span>
    
    <span class="c1"># ÉTAPE 1 : création et initialisation du tableau</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># remplissage première colonne</span>
        <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># remplissage première ligne</span>
        <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
    
    <span class="c1"># ÉTAPE 2 : remplissage du reste du tableau par indice croissant</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># attention ! le k-ième caractère d&#39;une chaîne est en position k-1</span>
                <span class="n">cout_sub</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># correspondance</span>
            <span class="k">else</span><span class="p">:</span>  
                <span class="n">cout_sub</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># substitution</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cout_sub</span><span class="p">)</span>        
    
    <span class="c1"># ÉTAPE 3 : le résultat est dans la dernière case</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">],</span> <span class="n">D</span>   <span class="c1"># on renvoie aussi le tableau D pour l&#39;observer</span>

<span class="c1"># ESSAI</span>
<span class="n">dE</span><span class="p">(</span><span class="s1">&#39;SUCCES&#39;</span><span class="p">,</span> <span class="s1">&#39;ECHECS&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[15]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>(4,
 [[0, 1, 2, 3, 4, 5, 6],
  [1, 1, 2, 3, 4, 5, 5],
  [2, 2, 2, 3, 4, 5, 6],
  [3, 3, 2, 3, 4, 4, 5],
  [4, 4, 3, 3, 4, 4, 5],
  [5, 4, 4, 4, 3, 4, 5],
  [6, 5, 5, 5, 4, 4, 4]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Contrairement à la version récursive naïve, on peut obtenir les distances entre deux chaînes assez longues.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dE</span><span class="p">(</span><span class="s1">&#39;ALGORITHME&#39;</span><span class="p">,</span> <span class="s1">&#39;ALGORIHTME&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[16]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>(2,
 [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
  [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8],
  [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7],
  [4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6],
  [5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5],
  [6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4],
  [7, 6, 5, 4, 3, 2, 1, 1, 1, 2, 3],
  [8, 7, 6, 5, 4, 3, 2, 1, 2, 2, 3],
  [9, 8, 7, 6, 5, 4, 3, 2, 2, 2, 3],
  [10, 9, 8, 7, 6, 5, 4, 3, 3, 3, 2]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Alignement-optimal">Alignement optimal<a class="anchor-link" href="#Alignement-optimal">&#182;</a></h3><p>Pour trouver un alignement optimal entre $T_1$ et $T_2$ il suffit de <em>remonter</em> depuis <code>D[n1][n2]</code> vers <code>D[0][0]</code> (de la case en bas à droite à celle en haut à gauche) en considérant à chaque fois le "meilleur" des 3 voisins, c'est-à-dire celui par lequel on a pu arriver ! (il peut parfois y en avoir plusieurs).</p>
<ul>
<li>Si on monte, il s'agit d'une suppression</li>
<li>Si on va à gauche, il s'agit d'une insertion</li>
<li>Si on va en diagonale, il s'agit d'une substitution ou d'une correspondance</li>
</ul>
<p>Par exemple, le tableau <code>D</code> correspondant à l'alignement entre SUCCES et ECHECS est :</p>
<p><img src="data/tableau_align_seq3.png" alt="alignement optimal"></p>
<p>On peut alors construire un alignement optimal (en partant de la fin ou du début) :</p>

<pre><code>S U C C E - S 
- E C H E C S</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Conclusion">Conclusion<a class="anchor-link" href="#Conclusion">&#182;</a></h1><ul>
<li>La <strong>programmation dynamique</strong> est une technique permettant d'améliorer l'efficacité d'un algorithme en <em>évitant les calculs redondants</em>.</li>
<li>Pour cela, on utilise un tableau (ou un dictionnaire) pour stocker les résultats intermédiaires et pouvoir les réutiliser sans les recalculer.</li>
<li>Comme la méthode &laquo; diviser pour régner &raquo;, la programmation dynamique permet résoudre un problème à partir des solutions de sous-problèmes. Si ces derniers se &laquo; chevauchent &raquo; (s'ils sont non indépendants) alors la programmation dynamique permettra d'éviter que les appels récursifs ne soient effectués plusieurs fois. Ainsi, la programmation dynamique permet souvent d'améliorer des algorithmes récursifs.</li>
<li>Pour utiliser la programmation dynamique, on procède généralement ainsi :<ol>
<li>définition des sous-problèmes</li>
<li>identification d'une relation de récurrence les solutions des sous-problèmes</li>
<li>mise en place d'un algorithme récursif avec mémoïsation ou d'un algorithme itératif ascendant</li>
<li>résolution du problème original à partir des solutions des sous-problèmes</li>
</ol>
</li>
<li>La programmation dynamique permet de résoudre de manière efficace de nombreux problèmes d'optimisation, comme le rendu de monnaie ou l'alignement de séquences, pour lesquels une solution récursive classique est inefficace.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<p><strong>Références :</strong></p>
<ul>
<li>Equipe pédagogique DIU EIL, Université de Nantes.</li>
<li>Articles Wikipédia sur la <a href="https://fr.wikipedia.org/wiki/Programmation_dynamique">Programmation dynamique</a> et sur la <a href="https://fr.wikipedia.org/wiki/Distance_de_Levenshtein">Distance de Levensthein</a> </li>
<li>Livre <em>Spécialité Numérique et sciences informatiques : 24 leçons avec exercices corrigés - Terminale</em>, éditions Ellipses, T. Balabonski, S. Conchon, J.-C. Filliâtre, K. Nguyen. Site du livre : <a href="http://www.nsi-terminale.fr/">http://www.nsi-terminale.fr/</a> pour l'idée de l'exercice 2 notamment.</li>
<li>Cours de David Roche sur le Pixees : <a href="https://pixees.fr/informatiquelycee/n_site/nsi_term_algo_progdyn.html">Programmation dynamique</a></li>
<li>Un cours sur la programmation dynamique : <a href="http://www-desir.lip6.fr/~spanjaard/pmwiki/uploads/ProgrammationDynamique.pdf">http://www-desir.lip6.fr/~spanjaard/pmwiki/uploads/ProgrammationDynamique.pdf</a></li>
</ul>
<hr>
<p>Germain BECKER, Lycée Mounier, ANGERS</p>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Licence Creative Commons"></p>

</div>
</div>
</div>
 

